(function () {
	'use strict';

	function noop() {}

	function assign(tar, src) {
		for (var k in src) tar[k] = src[k];
		return tar;
	}

	function addLoc(element, file, line, column, char) {
		element.__svelte_meta = {
			loc: { file, line, column, char }
		};
	}

	function run(fn) {
		fn();
	}

	function append(target, node) {
		target.appendChild(node);
	}

	function insert(target, node, anchor) {
		target.insertBefore(node, anchor);
	}

	function detachNode(node) {
		node.parentNode.removeChild(node);
	}

	function destroyEach(iterations, detach) {
		for (var i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) iterations[i].d(detach);
		}
	}

	function createElement(name) {
		return document.createElement(name);
	}

	function createText(data) {
		return document.createTextNode(data);
	}

	function addListener(node, event, handler) {
		node.addEventListener(event, handler, false);
	}

	function removeListener(node, event, handler) {
		node.removeEventListener(event, handler, false);
	}

	function setData(text, data) {
		text.data = '' + data;
	}

	function blankObject() {
		return Object.create(null);
	}

	function destroy(detach) {
		this.destroy = noop;
		this.fire('destroy');
		this.set = noop;

		this._fragment.d(detach !== false);
		this._fragment = null;
		this._state = {};
	}

	function destroyDev(detach) {
		destroy.call(this, detach);
		this.destroy = function() {
			console.warn('Component was already destroyed');
		};
	}

	function _differs(a, b) {
		return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
	}

	function fire(eventName, data) {
		var handlers =
			eventName in this._handlers && this._handlers[eventName].slice();
		if (!handlers) return;

		for (var i = 0; i < handlers.length; i += 1) {
			var handler = handlers[i];

			if (!handler.__calling) {
				try {
					handler.__calling = true;
					handler.call(this, data);
				} finally {
					handler.__calling = false;
				}
			}
		}
	}

	function flush(component) {
		component._lock = true;
		callAll(component._beforecreate);
		callAll(component._oncreate);
		callAll(component._aftercreate);
		component._lock = false;
	}

	function get() {
		return this._state;
	}

	function init(component, options) {
		component._handlers = blankObject();
		component._slots = blankObject();
		component._bind = options._bind;
		component._staged = {};

		component.options = options;
		component.root = options.root || component;
		component.store = options.store || component.root.store;

		if (!options.root) {
			component._beforecreate = [];
			component._oncreate = [];
			component._aftercreate = [];
		}
	}

	function on(eventName, handler) {
		var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
		handlers.push(handler);

		return {
			cancel: function() {
				var index = handlers.indexOf(handler);
				if (~index) handlers.splice(index, 1);
			}
		};
	}

	function set(newState) {
		this._set(assign({}, newState));
		if (this.root._lock) return;
		flush(this.root);
	}

	function _set(newState) {
		var oldState = this._state,
			changed = {},
			dirty = false;

		newState = assign(this._staged, newState);
		this._staged = {};

		for (var key in newState) {
			if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;
		}
		if (!dirty) return;

		this._state = assign(assign({}, oldState), newState);
		this._recompute(changed, this._state);
		if (this._bind) this._bind(changed, this._state);

		if (this._fragment) {
			this.fire("state", { changed: changed, current: this._state, previous: oldState });
			this._fragment.p(changed, this._state);
			this.fire("update", { changed: changed, current: this._state, previous: oldState });
		}
	}

	function _stage(newState) {
		assign(this._staged, newState);
	}

	function setDev(newState) {
		if (typeof newState !== 'object') {
			throw new Error(
				this._debugName + '.set was called without an object of data key-values to update.'
			);
		}

		this._checkReadOnly(newState);
		set.call(this, newState);
	}

	function callAll(fns) {
		while (fns && fns.length) fns.shift()();
	}

	function _mount(target, anchor) {
		this._fragment[this._fragment.i ? 'i' : 'm'](target, anchor || null);
	}

	var protoDev = {
		destroy: destroyDev,
		get,
		fire,
		on,
		set: setDev,
		_recompute: noop,
		_set,
		_stage,
		_mount,
		_differs
	};

	/* src\Pagination\Pagination.html generated by Svelte v2.13.4 */

	const loc = window.location;

	function isBegin({current}) {
	    return current < 2;
	}

	function isEnd({current, total}) {
	    return current >= total;
	}

	function items({current, total, show}) {
					let arr = [],
						d = Math.floor(show / 2),
						b = current > total - d ? total - show + 1 : (current > d ? current - d: 1);
					for(let i = 0; i < show; i++) {
						let c = b + i,
							disabled = (i === 0 && c >= d && c < current) ||
								(i === show -1 && c <= total - d + 1);
						arr.push({
							nm: disabled ? '…' : c,
							disabled: disabled,
							active: current === c
						});
					}
					return arr;
	}

	function data() {
		return {
			hashLang: {},
			show: 5,
			total: 20,
			current: 1
		}
	}
	var methods = {
		gotoPage(nm) {
			if (typeof(nm) === 'number') {
				let {total} = this.get();
				this.set({current: nm > total ? total : (nm < 1 ? 1 : nm)});
			}
		}
	};

	const file = "src\\Pagination\\Pagination.html";

	function create_main_fragment(component, ctx) {
		var ul, text, text_1, current;

		var if_block = (ctx.total > ctx.show) && create_if_block(component, ctx);

		var each_value = ctx.items;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block(component, get_each_context(ctx, each_value, i));
		}

		var if_block_1 = (ctx.total > ctx.show) && create_if_block_1(component, ctx);

		return {
			c: function create() {
				ul = createElement("ul");
				if (if_block) if_block.c();
				text = createText("\n\t");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				text_1 = createText("\n\t");
				if (if_block_1) if_block_1.c();
				ul.className = "pagination svelte-1tm23wa";
				addLoc(ul, file, 0, 0, 0);
			},

			m: function mount(target, anchor) {
				insert(target, ul, anchor);
				if (if_block) if_block.m(ul, null);
				append(ul, text);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(ul, null);
				}

				append(ul, text_1);
				if (if_block_1) if_block_1.m(ul, null);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.total > ctx.show) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block(component, ctx);
						if_block.c();
						if_block.m(ul, text);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (changed.items) {
					each_value = ctx.items;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(ul, text_1);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}

				if (ctx.total > ctx.show) {
					if (if_block_1) {
						if_block_1.p(changed, ctx);
					} else {
						if_block_1 = create_if_block_1(component, ctx);
						if_block_1.c();
						if_block_1.m(ul, null);
					}
				} else if (if_block_1) {
					if_block_1.d(1);
					if_block_1 = null;
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(ul);
				}

				if (if_block) if_block.d();

				destroyEach(each_blocks, detach);

				if (if_block_1) if_block_1.d();
			}
		};
	}

	// (2:1) {#if total > show}
	function create_if_block(component, ctx) {
		var li, text, li_class_value, text_1, li_1, text_2, li_1_class_value;

		function click_handler(event) {
			component.gotoPage(1);
		}

		function click_handler_1(event) {
			component.gotoPage(ctx.current - 1);
		}

		return {
			c: function create() {
				li = createElement("li");
				text = createText("«");
				text_1 = createText("\n\t\t");
				li_1 = createElement("li");
				text_2 = createText("‹");
				addListener(li, "click", click_handler);
				li.className = li_class_value = "" + (ctx.isBegin ? 'disabled' : '') + " svelte-1tm23wa";
				addLoc(li, file, 2, 2, 46);
				addListener(li_1, "click", click_handler_1);
				li_1.className = li_1_class_value = "" + (ctx.isBegin ? 'disabled' : '') + " svelte-1tm23wa";
				addLoc(li_1, file, 3, 2, 118);
			},

			m: function mount(target, anchor) {
				insert(target, li, anchor);
				append(li, text);
				insert(target, text_1, anchor);
				insert(target, li_1, anchor);
				append(li_1, text_2);
			},

			p: function update(changed, _ctx) {
				ctx = _ctx;
				if ((changed.isBegin) && li_class_value !== (li_class_value = "" + (ctx.isBegin ? 'disabled' : '') + " svelte-1tm23wa")) {
					li.className = li_class_value;
				}

				if ((changed.isBegin) && li_1_class_value !== (li_1_class_value = "" + (ctx.isBegin ? 'disabled' : '') + " svelte-1tm23wa")) {
					li_1.className = li_1_class_value;
				}
			},

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(li);
				}

				removeListener(li, "click", click_handler);
				if (detach) {
					detachNode(text_1);
					detachNode(li_1);
				}

				removeListener(li_1, "click", click_handler_1);
			}
		};
	}

	// (6:1) {#each items as it}
	function create_each_block(component, ctx) {
		var li, text_value = ctx.it.nm, text, li_class_value;

		return {
			c: function create() {
				li = createElement("li");
				text = createText(text_value);
				li._svelte = { component, ctx };

				addListener(li, "click", click_handler);
				li.className = li_class_value = "" + (ctx.it.active ? 'active' : '') + " " + (ctx.it.nm > 0 ? '' : 'disabled') + " svelte-1tm23wa";
				addLoc(li, file, 6, 2, 228);
			},

			m: function mount(target, anchor) {
				insert(target, li, anchor);
				append(li, text);
			},

			p: function update(changed, ctx) {
				if ((changed.items) && text_value !== (text_value = ctx.it.nm)) {
					setData(text, text_value);
				}

				li._svelte.ctx = ctx;
				if ((changed.items) && li_class_value !== (li_class_value = "" + (ctx.it.active ? 'active' : '') + " " + (ctx.it.nm > 0 ? '' : 'disabled') + " svelte-1tm23wa")) {
					li.className = li_class_value;
				}
			},

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(li);
				}

				removeListener(li, "click", click_handler);
			}
		};
	}

	// (12:1) {#if total > show}
	function create_if_block_1(component, ctx) {
		var li, span, text, li_class_value, text_1, li_1, span_1, text_2, li_1_class_value;

		function click_handler_1(event) {
			component.gotoPage(ctx.current + 1);
		}

		function click_handler_2(event) {
			component.gotoPage(ctx.total);
		}

		return {
			c: function create() {
				li = createElement("li");
				span = createElement("span");
				text = createText("›");
				text_1 = createText("\n\t\t");
				li_1 = createElement("li");
				span_1 = createElement("span");
				text_2 = createText("»");
				addLoc(span, file, 12, 73, 449);
				addListener(li, "click", click_handler_1);
				li.className = li_class_value = "" + (ctx.isEnd ? 'disabled' : '') + " svelte-1tm23wa";
				addLoc(li, file, 12, 2, 378);
				addLoc(span_1, file, 13, 67, 536);
				addListener(li_1, "click", click_handler_2);
				li_1.className = li_1_class_value = "" + (ctx.isEnd ? 'disabled' : '') + " svelte-1tm23wa";
				addLoc(li_1, file, 13, 2, 471);
			},

			m: function mount(target, anchor) {
				insert(target, li, anchor);
				append(li, span);
				append(span, text);
				insert(target, text_1, anchor);
				insert(target, li_1, anchor);
				append(li_1, span_1);
				append(span_1, text_2);
			},

			p: function update(changed, _ctx) {
				ctx = _ctx;
				if ((changed.isEnd) && li_class_value !== (li_class_value = "" + (ctx.isEnd ? 'disabled' : '') + " svelte-1tm23wa")) {
					li.className = li_class_value;
				}

				if ((changed.isEnd) && li_1_class_value !== (li_1_class_value = "" + (ctx.isEnd ? 'disabled' : '') + " svelte-1tm23wa")) {
					li_1.className = li_1_class_value;
				}
			},

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(li);
				}

				removeListener(li, "click", click_handler_1);
				if (detach) {
					detachNode(text_1);
					detachNode(li_1);
				}

				removeListener(li_1, "click", click_handler_2);
			}
		};
	}

	function get_each_context(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.it = list[i];
		child_ctx.each_value = list;
		child_ctx.it_index = i;
		return child_ctx;
	}

	function click_handler(event) {
		const { component, ctx } = this._svelte;

		component.gotoPage(ctx.it.nm);
	}

	function Pagination(options) {
		this._debugName = '<Pagination>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign(data(), options.data);
		this._recompute({ current: 1, total: 1, show: 1 }, this._state);
		if (!('current' in this._state)) console.warn("<Pagination> was created without expected data property 'current'");
		if (!('total' in this._state)) console.warn("<Pagination> was created without expected data property 'total'");
		if (!('show' in this._state)) console.warn("<Pagination> was created without expected data property 'show'");
		this._intro = !!options.intro;

		this._fragment = create_main_fragment(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}

		this._intro = true;
	}

	assign(Pagination.prototype, protoDev);
	assign(Pagination.prototype, methods);

	Pagination.prototype._checkReadOnly = function _checkReadOnly(newState) {
		if ('isBegin' in newState && !this._updatingReadonlyProperty) throw new Error("<Pagination>: Cannot set read-only property 'isBegin'");
		if ('isEnd' in newState && !this._updatingReadonlyProperty) throw new Error("<Pagination>: Cannot set read-only property 'isEnd'");
		if ('items' in newState && !this._updatingReadonlyProperty) throw new Error("<Pagination>: Cannot set read-only property 'items'");
	};

	Pagination.prototype._recompute = function _recompute(changed, state) {
		if (changed.current) {
			if (this._differs(state.isBegin, (state.isBegin = isBegin(state)))) changed.isBegin = true;
		}

		if (changed.current || changed.total) {
			if (this._differs(state.isEnd, (state.isEnd = isEnd(state)))) changed.isEnd = true;
		}

		if (changed.current || changed.total || changed.show) {
			if (this._differs(state.items, (state.items = items(state)))) changed.items = true;
		}
	};

	new Pagination({
		target: document.getElementById('app'),
		data: {
			total: 16
		}
	});

}());
//# sourceMappingURL=bundle.js.map
